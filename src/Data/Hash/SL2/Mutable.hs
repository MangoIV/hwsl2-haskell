module Data.Hash.SL2.Mutable
  ( eq
  , unit
  , concat
  , append, prepend
  , foldAppend, foldPrepend
  , serialize, unserialize
  ) where

import Prelude hiding (concat)

import Foreign
import Foreign.C.String

import Data.ByteString (ByteString)
import Data.ByteString.Unsafe

import Data.Foldable (Foldable, foldlM, foldrM)

import Data.Hash.SL2.Internal
import Data.Hash.SL2.Unsafe
import qualified Data.Hash.SL2.Internal.Imports as Imports

instance Storable Hash where
  sizeOf = const tzHashSize
  alignment = const 0
  peek p = fmap fst $ withHashPtrNew $ \hp -> copyBytes hp (castPtr p) tzHashSize
  poke p h = unsafeUseAsPtr h $ \hp -> copyBytes (castPtr p) hp tzHashSize

-- | /O(1)/ Compare the two hashes for equality.
eq :: Ptr Hash -> Ptr Hash -> IO Bool
eq a b = fmap toBool $ Imports.eq a b

-- | /O(1)/ Set the 'Hash' to the empty value.
unit :: Ptr Hash -> IO ()
unit h = Imports.unit h

-- | /O(1)/ Concatenate the second and third 'Hash', store the result in the first.
concat :: Ptr Hash -> Ptr Hash -> Ptr Hash -> IO ()
concat c a b = Imports.concat c a b

-- | /O(n)/ Append the hash of the 'ByteString' to the existing 'Hash'.
append :: ByteString -> Ptr Hash -> IO ()
append s p = unsafeUseAsCStringLen s $ \(s', len) -> Imports.append (castPtr p) s' (fromIntegral len)

-- | /O(n)/ Prepend the hash of the 'ByteString' to the existing 'Hash'.
prepend :: ByteString -> Ptr Hash -> IO ()
prepend s p = unsafeUseAsCStringLen s $ \(s', len) -> Imports.prepend (castPtr p) s' (fromIntegral len)

-- | /O(n)/ Append the hash of every 'ByteString' to the existing 'Hash', from left to right.
foldAppend :: Foldable t => t ByteString -> Ptr Hash -> IO ()
foldAppend ss p = foldlM (const (flip append p)) () ss

-- | /O(n)/ Prepend the hash of every 'ByteString' to the existing 'Hash', from right to left.
foldPrepend :: Foldable t => t ByteString -> Ptr Hash -> IO ()
foldPrepend ss p = foldrM (\s _ -> prepend s p) () ss

-- | /O(1)/ Serialize the hash into a url-safe base64 representation.
serialize :: Ptr Hash -> IO String
serialize h = allocaBytes tzHashLen $ \p -> Imports.serialize h p >> peekCStringLen (p, tzHashLen)

-- | /O(1)/ Unserialize the hash from the representation generated by 'serialize'.
unserialize :: String -> Ptr Hash -> IO (Maybe ())
unserialize s p = withCAStringLen s $ \(s', len) ->
  if len == tzHashLen then fmap Just (Imports.unserialize p s') else return Nothing
